<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker | Zeno Blog</title>
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/zeno-blog/icons/favicon.ico">
    <link rel="manifest" href="/zeno-blog/manifest.json">
    <link rel="apple-touch-icon" href="/zeno-blog/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/zeno-blog/icons/safari-pinned-tab.svg" color="#000000">
    <meta name="description" content="You cannot find peace by avoiding life.">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/zeno-blog/assets/css/0.styles.2a2e5ad3.css" as="style"><link rel="preload" href="/zeno-blog/assets/js/app.9211a5da.js" as="script"><link rel="preload" href="/zeno-blog/assets/js/3.3b039ebf.js" as="script"><link rel="preload" href="/zeno-blog/assets/js/1.8ae41a42.js" as="script"><link rel="preload" href="/zeno-blog/assets/js/28.903942bf.js" as="script"><link rel="preload" href="/zeno-blog/assets/js/9.54de9460.js" as="script"><link rel="prefetch" href="/zeno-blog/assets/js/10.04390c87.js"><link rel="prefetch" href="/zeno-blog/assets/js/11.e5336b03.js"><link rel="prefetch" href="/zeno-blog/assets/js/12.5663ed58.js"><link rel="prefetch" href="/zeno-blog/assets/js/13.189b6a7a.js"><link rel="prefetch" href="/zeno-blog/assets/js/14.711d9684.js"><link rel="prefetch" href="/zeno-blog/assets/js/15.c2ce1fef.js"><link rel="prefetch" href="/zeno-blog/assets/js/16.977465c4.js"><link rel="prefetch" href="/zeno-blog/assets/js/17.66d8c795.js"><link rel="prefetch" href="/zeno-blog/assets/js/18.6bdd9baa.js"><link rel="prefetch" href="/zeno-blog/assets/js/19.815cb295.js"><link rel="prefetch" href="/zeno-blog/assets/js/20.ee71a9a0.js"><link rel="prefetch" href="/zeno-blog/assets/js/21.2b5b09c2.js"><link rel="prefetch" href="/zeno-blog/assets/js/22.9734a503.js"><link rel="prefetch" href="/zeno-blog/assets/js/23.1475c307.js"><link rel="prefetch" href="/zeno-blog/assets/js/24.8dee7392.js"><link rel="prefetch" href="/zeno-blog/assets/js/25.58dfc138.js"><link rel="prefetch" href="/zeno-blog/assets/js/26.5326878a.js"><link rel="prefetch" href="/zeno-blog/assets/js/27.4be984be.js"><link rel="prefetch" href="/zeno-blog/assets/js/29.0f30f0ab.js"><link rel="prefetch" href="/zeno-blog/assets/js/30.9fbea95c.js"><link rel="prefetch" href="/zeno-blog/assets/js/31.1a05277e.js"><link rel="prefetch" href="/zeno-blog/assets/js/32.cf412315.js"><link rel="prefetch" href="/zeno-blog/assets/js/33.0a09b078.js"><link rel="prefetch" href="/zeno-blog/assets/js/34.bc35e353.js"><link rel="prefetch" href="/zeno-blog/assets/js/35.95b848cb.js"><link rel="prefetch" href="/zeno-blog/assets/js/36.6e87a83a.js"><link rel="prefetch" href="/zeno-blog/assets/js/4.fb2513d9.js"><link rel="prefetch" href="/zeno-blog/assets/js/5.76a1324f.js"><link rel="prefetch" href="/zeno-blog/assets/js/6.a28c1884.js"><link rel="prefetch" href="/zeno-blog/assets/js/7.aa3ab8d4.js"><link rel="prefetch" href="/zeno-blog/assets/js/8.e45da13b.js">
    <link rel="stylesheet" href="/zeno-blog/assets/css/0.styles.2a2e5ad3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-19557b78><div data-v-19557b78><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-19557b78 data-v-19557b78><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-19557b78 data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Zeno Blog</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Zeno</span>
            
          <span data-v-64685f0e>2019 - </span>
          2024
        </a></span></div></div> <div class="hide" data-v-19557b78><header class="navbar" data-v-19557b78><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zeno-blog/" class="home-link router-link-active"><img src="/zeno-blog/images/head.jpg" alt="Zeno Blog" class="logo"> <span class="site-name">Zeno Blog</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zeno-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Nginx/" class="nav-link"><i class="iconfont undefined"></i>
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/JavaScript/" class="nav-link"><i class="iconfont undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Vite/" class="nav-link"><i class="iconfont undefined"></i>
  Vite
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Docker/" class="nav-link"><i class="iconfont undefined"></i>
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Tools/" class="nav-link"><i class="iconfont undefined"></i>
  Tools
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/其他/" class="nav-link"><i class="iconfont undefined"></i>
  其他
</a></li></ul></div></div><div class="nav-item"><a href="/zeno-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/zeno-blog/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-19557b78></div> <aside class="sidebar" data-v-19557b78><div class="personal-info-wrapper" data-v-042e23d4><img src="/zeno-blog/images/head.jpg" alt="author-avatar" class="personal-img" data-v-042e23d4> <h3 class="name" data-v-042e23d4>
    Zeno
  </h3> <div class="num" data-v-042e23d4><div data-v-042e23d4><h3 data-v-042e23d4>25</h3> <h6 data-v-042e23d4>Article</h6></div> <div data-v-042e23d4><h3 data-v-042e23d4>8</h3> <h6 data-v-042e23d4>Tag</h6></div></div> <hr data-v-042e23d4></div> <nav class="nav-links"><div class="nav-item"><a href="/zeno-blog/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Nginx/" class="nav-link"><i class="iconfont undefined"></i>
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/React/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/JavaScript/" class="nav-link"><i class="iconfont undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Vite/" class="nav-link"><i class="iconfont undefined"></i>
  Vite
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Docker/" class="nav-link"><i class="iconfont undefined"></i>
  Docker
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/Tools/" class="nav-link"><i class="iconfont undefined"></i>
  Tools
</a></li><li class="dropdown-item"><!----> <a href="/zeno-blog/categories/其他/" class="nav-link"><i class="iconfont undefined"></i>
  其他
</a></li></ul></div></div><div class="nav-item"><a href="/zeno-blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/zeno-blog/timeLine/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Docker</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/zeno-blog/views/docker/docker.html#学习资源" class="sidebar-link">学习资源</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#官方文档" class="sidebar-link">官方文档</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#第三方中文文档" class="sidebar-link">第三方中文文档</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#在线平台" class="sidebar-link">在线平台</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#docker简介" class="sidebar-link">Docker简介</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zeno-blog/views/docker/docker.html#安装配置docker" class="sidebar-link">安装配置Docker</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#mac" class="sidebar-link">Mac</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#linux" class="sidebar-link">Linux</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#docker镜像" class="sidebar-link">Docker镜像</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#官方镜像仓库" class="sidebar-link">官方镜像仓库</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#构建镜像" class="sidebar-link">构建镜像</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#发布到官方镜像仓库" class="sidebar-link">发布到官方镜像仓库</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#发布-拉取私有镜像仓库" class="sidebar-link">发布/拉取私有镜像仓库</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#dockerfile详解" class="sidebar-link">Dockerfile详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#dockerfile指令" class="sidebar-link">Dockerfile指令</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#优化技巧" class="sidebar-link">优化技巧</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#忽略文件" class="sidebar-link">忽略文件</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#其他技巧" class="sidebar-link">其他技巧</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#docker容器" class="sidebar-link">Docker容器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#容器基础" class="sidebar-link">容器基础</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#容器网络" class="sidebar-link">容器网络</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#多容器通信" class="sidebar-link">多容器通信</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#容器挂载目录" class="sidebar-link">容器挂载目录</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#docker-compose" class="sidebar-link">Docker-Compose</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#安装" class="sidebar-link">安装</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#配置文件" class="sidebar-link">配置文件</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#备份和迁移数据" class="sidebar-link">备份和迁移数据</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zeno-blog/views/docker/docker.html#自动化流程" class="sidebar-link">自动化流程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zeno-blog/views/docker/docker.html#常用命令" class="sidebar-link">常用命令</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zeno-blog/views/docker/docker.html#常用的基础镜像" class="sidebar-link">常用的基础镜像</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#alpine" class="sidebar-link">Alpine</a></li><li class="sidebar-sub-header"><a href="/zeno-blog/views/docker/docker.html#node镜像" class="sidebar-link">Node镜像</a></li></ul></li><li><a href="/zeno-blog/views/docker/docker.html#踩坑第一弹" class="sidebar-link">踩坑第一弹</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zeno-blog/views/docker/docker.html#踩坑第二弹-容器时间" class="sidebar-link">踩坑第二弹: 容器时间</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-19557b78><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Docker</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Zeno</span>
            
          <span data-v-64685f0e>2019 - </span>
          2024
        </a></span></div></div> <div data-v-19557b78><main class="page"><div class="page-title" style="display:none;"><h1>Docker</h1> <hr> <div data-v-34ea29db><i class="iconfont reco-account" data-v-34ea29db><span data-v-34ea29db>Zeno</span></i> <i class="iconfont reco-date" data-v-34ea29db><span data-v-34ea29db>2024-03-10</span></i> <i class="iconfont reco-eye" data-v-34ea29db><span id="/zeno-blog/views/docker/docker.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-34ea29db><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <i class="iconfont reco-tag tags" data-v-34ea29db><span class="tag-item" data-v-34ea29db>Docker</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="学习资源"><a href="#学习资源" class="header-anchor">#</a> 学习资源</h2> <h3 id="官方文档"><a href="#官方文档" class="header-anchor">#</a> 官方文档</h3> <p><a href="http://www.dockerinfo.net/dockerfile%e4%bb%8b%e7%bb%8d" target="_blank" rel="noopener noreferrer">docker 中文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>docker的镜像仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">docker hub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>docker所有文档 <a href="https://docs.docker.com/" target="_blank" rel="noopener noreferrer">docker doc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <ul><li>docker 的命令行文档 <a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener noreferrer">Command-line reference<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>docker 的dockerfile文件文档 <a href="https://docs.docker.com/engine/reference/builder/#run" target="_blank" rel="noopener noreferrer">Dockerfile reference<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>docker数据的管理文档 <a href="https://docs.docker.com/storage/" target="_blank" rel="noopener noreferrer">docker storage<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>docker网络文档 <a href="https://docs.docker.com/engine/reference/commandline/network/" target="_blank" rel="noopener noreferrer">docker network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>docker compose文档 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener noreferrer">docker compose<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="第三方中文文档"><a href="#第三方中文文档" class="header-anchor">#</a> 第三方中文文档</h3> <p><a href="https://www.simapple.com/docker-tutorial" target="_blank" rel="noopener noreferrer">Docker简明教程——中文版<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener noreferrer">菜鸟教程——Docker命令大全<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="在线平台"><a href="#在线平台" class="header-anchor">#</a> 在线平台</h3> <p><a href="https://labs.play-with-docker.com/" target="_blank" rel="noopener noreferrer">play-with-docker<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：是由Docker公司赞助，免费提供在线的Docker操作平台，非常适合新手学习Docker使用</p> <h2 id="docker简介"><a href="#docker简介" class="header-anchor">#</a> Docker简介</h2> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-20220202133143406.png" alt="image-20220202133143406%20"></p> <p>Docker 是一个应用打包、分发、部署的工具，也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种可能并不需要的软件</p> <ul><li><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包</li> <li><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装</li> <li><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows/Mac/Linux</li></ul> <p>Docker版本：</p> <ul><li><p>社区版 docker-ce</p> <p>由社区维护和提供技术支持，为免费版本，适合个人开发人员和小团队使用。<strong>本文章以下内容使用的社区版本</strong></p></li> <li><p>企业版 docker-EE</p> <p>收费版本，由售后团队和技术团队提供技术支持，专为企业开发和 IT 团队而设计，相比 Docker-CE，增加一些额外功能，更重要的是提供了更安全的保障</p></li></ul> <h2 id="安装配置docker"><a href="#安装配置docker" class="header-anchor">#</a> 安装配置Docker</h2> <p>步骤分为两个部分</p> <ul><li><p>安装到机器</p></li> <li><p>配置镜像源</p> <p>Docker的默认官方远程仓库是hub.docker.com，由于网络原因，下载一个Docker官方镜像可能会需要很长的时间，甚至下载失败，所以我们需要配置镜像源。配置镜像源后，下载官方仓库（hub.docker.com）里的镜像时，才能更快的下载</p> <table><thead><tr><th>镜像加速器</th> <th>镜像加速器地址</th></tr></thead> <tbody><tr><td>Docker 中国官方镜像</td> <td><a href="https://registry.docker-cn.com/" target="_blank" rel="noopener noreferrer">https://registry.docker-cn.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>DaoCloud 镜像站</td> <td><a href="http://f1361db2.m.daocloud.io/" target="_blank" rel="noopener noreferrer">http://f1361db2.m.daocloud.io<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>Azure 中国镜像</td> <td><a href="https://dockerhub.azk8s.cn/" target="_blank" rel="noopener noreferrer">https://dockerhub.azk8s.cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>科大镜像站</td> <td><a href="https://docker.mirrors.ustc.edu.cn/" target="_blank" rel="noopener noreferrer">https://docker.mirrors.ustc.edu.cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>阿里云</td> <td>https://&lt;your_code&gt;.mirror.aliyuncs.com 【具体参见 <code>云服务器使用Docker</code>部分】</td></tr> <tr><td>七牛云</td> <td><a href="https://reg-mirror.qiniu.com/" target="_blank" rel="noopener noreferrer">https://reg-mirror.qiniu.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>网易云</td> <td><a href="https://hub-mirror.c.163.com/" target="_blank" rel="noopener noreferrer">https://hub-mirror.c.163.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr> <tr><td>腾讯云</td> <td><a href="https://mirror.ccs.tencentyun.com/" target="_blank" rel="noopener noreferrer">https://mirror.ccs.tencentyun.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></td></tr></tbody></table></li></ul> <p><strong>注意</strong>：</p> <p>在Win/Mac上可以安装桌面版Docker，提供可视化界面，操作更为简单</p> <p>在Linux系统上安装则需要使用命令</p> <h3 id="mac"><a href="#mac" class="header-anchor">#</a> Mac</h3> <p><strong>安装</strong></p> <ul><li><p>官网下载 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener noreferrer">https://www.docker.com/products/docker-desktop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>安装到Mac</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013016245407020.png" alt="image-20220130162454070"></p> <p>输入密码，接受协议</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013115274546620.png" alt="image-20220131152745466"></p> <p>安装成功，Docker桌面版主界面</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013016373099720.png" alt="image-20220130163730997"></p></li></ul> <p><strong>配置镜像源</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013017183425720.png" alt="image-20220130171834257"></p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013017330096620.png" alt="image-20220130173300966"></p> <h3 id="linux"><a href="#linux" class="header-anchor">#</a> Linux</h3> <p>推荐一种方式</p> <p><strong>方式一</strong></p> <p>下载脚本，自动安装Docker</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">curl</span> -fsSL https://get.docker.com <span class="token operator">|</span> <span class="token function">bash</span> -s docker --mirror Aliyun
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>方式二</strong></p> <p>使用yum下载</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><strong>docker-ce</strong>：Docker守护进程，负责所有的容器管理工作，在 Linux 上依赖另外两个完成工作</p></li> <li><p><strong>docker-ce-cli</strong> ：用于控制Docker守护进程的 CLI 工具（可以通过CLI工具控制远程 Docker 守护进程）</p></li> <li><p><strong>containerd.io</strong> ： 守护进程与操作系统之间的接口层，本质上将Docker与操作系统分离</p> <blockquote><p>containerd 可用作 Linux 和 Windows 的守护程序。 它管理其主机系统的完整容器生命周期，从图像传输和存储到容器执行和监督，再到低级存储到网络附件等等</p></blockquote></li></ul> <p>启动docker守护进程</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>systemctl start docker
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>查看docker进程状态</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>systemctl start docker
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>卸载docker</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>yum remove docker-ce <span class="token comment">#卸载</span>

<span class="token function">rm</span> -rf /var/lib/docker <span class="token comment">#删除镜像、容器、配置文件等内容</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="docker镜像"><a href="#docker镜像" class="header-anchor">#</a> Docker镜像</h2> <ul><li><p>镜像类似于软件的安装包</p></li> <li><p>容器中运行着某一个镜像，容器之间彼此独立互不影响</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 新建容器，其中运行指定镜像</span>
docker run <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> IMAGE <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span> <span class="token punctuation">[</span>ARG<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul> <h3 id="官方镜像仓库"><a href="#官方镜像仓库" class="header-anchor">#</a> 官方镜像仓库</h3> <p>docker hub是官方提供的镜像仓库，直接在<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">docker hub 官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>搜索想要安装在docker中的软件，根据搜索结果的指示进行安装</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013017392416620.png" alt="image-20220130173924166"></p> <p>以安装redis为例子，进入该镜像的描述页，有详细的使用方法</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013017530890420.png" alt="image-20220130175308904"></p> <p><strong>查找镜像</strong></p> <p>在Docker hub中查找</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker search redis

<span class="token comment"># 字段含义</span>
<span class="token comment"># NAME: 镜像仓库源的名称</span>
<span class="token comment"># DESCRIPTION: 镜像的描述</span>
<span class="token comment"># stars: 点赞数</span>
<span class="token comment"># OFFICIAL: 是否 docker 官方发布</span>
<span class="token comment"># AUTOMATED: 自动构建</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022091720584520.png" alt="image-20220917205844794"></p> <p><strong>下载镜像</strong></p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>docker pull redis 

<span class="token comment"># 不指定镜像的版本号，默认下载latest，即最新版本</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022091721034920.png" alt="image-20220917210349448"></p> <p><strong>查看本地已下载镜像列表</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker images
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022091721054020.png" alt="image-20220917210539975"></p> <p><strong>删除本地镜像</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker rmi redis
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="构建镜像"><a href="#构建镜像" class="header-anchor">#</a> 构建镜像</h3> <p>当 docker 镜像仓库中下载的镜像不能满足需求时，可以通过以下两种方式构建自己的镜像</p> <ul><li><p>使用 Dockerfile 指令来创建一个新的镜像（docker build 是把 镜像/源码——&gt;镜像）</p></li> <li><p>把容器打包为镜像（docker commit 是把 容器——&gt;镜像）</p></li></ul> <p><strong>Dockerfile构建镜像</strong></p> <p>这里使用一个简单地Gin框架项目，来构建镜像</p> <p>初始化项目</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>go mod init DockerBuild
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>新建文件main.go</p> <div class="language-go line-numbers-mode"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;github.com/gin-gonic/gin&quot;</span>
	<span class="token string">&quot;net/http&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	r <span class="token operator">:=</span> gin<span class="token punctuation">.</span><span class="token function">Default</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	r<span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span>
			<span class="token string">&quot;msg&quot;</span><span class="token punctuation">:</span> <span class="token string">&quot;ok&quot;</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	r<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token string">&quot;:8888&quot;</span><span class="token punctuation">)</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>dockerfile</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> golang</span>

<span class="token comment"># 为镜像设置必要的环境变量(Go编译时需要)</span>
<span class="token instruction"><span class="token keyword">ENV</span> CGO_ENABLED=0 <span class="token operator">\</span>
    GOOS=linux <span class="token operator">\</span>
    GOARCH=amd64</span>

<span class="token comment"># 容器内，移动到`/build`内</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /build</span>

<span class="token comment"># 将本地文件 复制 到容器内（第一个点是执行docker build命令所在的目录，第二个点是容器内的路径，即在/build目录下）</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token comment"># 将代码编译成二进制可执行文件（文件名为app），这个点是容器内的/build目录下</span>
<span class="token instruction"><span class="token keyword">RUN</span> go build -o app .</span>

<span class="token comment"># 声明服务端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8888</span>


<span class="token comment"># 启动容器时运行的命令（点是容器内路径/build目录，即运行/build/app文件）</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;./app&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在项目目录下执行构建镜像命令</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker build -t higo:v1 <span class="token builtin class-name">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>注意</strong>：<code>.</code> 是指上下文路径，指定当前目录为上下文路径，<code>docker build</code> 命令会将该目录下的全部内容交给 Docker 引擎来构建镜像</p> <p>所以，上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p> <p>如果确实上下文目录下有些文件，不需要打包给docker，可以在上下文目录下添加忽略文件<code>.dockerignore</code></p> <p><strong>从容器中构建镜像</strong></p> <p>把一个正在运行的容器，构建为一个新的镜像【注意：容器必须是运行状态】</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker commit <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span><span class="token punctuation">[</span>新的镜像名:版本号<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="发布到官方镜像仓库"><a href="#发布到官方镜像仓库" class="header-anchor">#</a> 发布到官方镜像仓库</h3> <ul><li><p>在docker的镜像仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">docker hub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，注册用户（注册时填写 用户名+邮箱+密码，国外的东东都喜欢在命令行中使用这个用户名作为用户标识，所以记住啊）</p></li> <li><p>创建一个镜像仓库</p> <p>官方仓库远程镜像仓库的地址：用户名/镜像仓库名</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020118274174520.png" alt="image-20220201182741745"></p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022091802264020.png" alt="image-20220918022640359"></p></li> <li><p>本地登录到官方仓库</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker login -u 用户名 <span class="token comment"># 之后要求输入密码</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>给待发布的镜像打标记（给镜像起个新名字+版本号，打标记会在本地重新生成以tag命名的新镜像）</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker tag local-image:tag remote-repo:tag

<span class="token comment"># username是用户名</span>
<span class="token comment"># local-image:tag  是本地待发布的镜像的名字和版本号</span>
<span class="token comment"># remote-repo:tag  是发布到远程后的名字和版本号</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>注意</strong>：远程镜像仓库的地址，官方远程仓库地址一般为：用户名/镜像仓库名</p> <p>例如，我的远程仓库地址：hyjhyj1098/test，其中hyjhyj1098是用户名，test是仓库名，所以我的标记为</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker tag test:v1 hyjhyj1098/test:v1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以看到<code>Images</code>选项卡下多了一个<code>hyjhyj1098/test</code>的镜像</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020118442322020.png" alt="image-20220201184423220"></p></li> <li><p>推送到远程仓库</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker push remote-repo:tag
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以在网站看到上传的镜像</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020119185421120.png" alt="image-20220201191854211"></p></li></ul> <h3 id="发布-拉取私有镜像仓库"><a href="#发布-拉取私有镜像仓库" class="header-anchor">#</a> 发布/拉取私有镜像仓库</h3> <p>上面一直使用的镜像仓库都是官方的，实际上企业一般使用内部的私有镜像仓库（类似于企业一般使用gitlab搭建的内部仓库，而不是github）</p> <p>两者的基本流程是一样的</p> <ul><li><p>创建阿里云镜像仓库（如果有条件可以搭建私有仓库）</p> <p>访问阿里云容器镜像服务(<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener noreferrer">https://cr.console.aliyun.com/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)，在实例列表里有两个选项，分别是个人实例和企业实例，目前个人实例免费，按照流程创建命名空间（一个命名空间下，可以放多个镜像仓库）即可</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020119314048120.png" alt="image-20220201193140481"></p></li> <li><p>本地登录到阿里私有镜像仓库</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker login <span class="token operator">&lt;</span>镜像服务地址<span class="token operator">&gt;</span>

<span class="token comment">#我这里的&lt;镜像服务地址&gt;是：registry.cn-hangzhou.aliyuncs.com</span>
<span class="token comment">#然后按照提示，输入用户名和密码</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022031920550301920.png" alt="image-20220319205503019"></p></li> <li><p>给待发布的镜像打标记</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker tag  local-image:tag  new-repo:tag

<span class="token comment"># local-image:tag  是本地待发布的镜像的名字和版本号</span>
<span class="token comment"># new-repo:tag  是发布到远程后的名字和版本号 ，这里是：registry.cn-hangzhou.aliyuncs.com/hyj_aliyun/test1:[镜像版本号]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>推送到阿里私有镜像仓</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker push tag <span class="token comment">#上一步打的tag是：registry.cn-hangzhou.aliyuncs.com/hyj_aliyun/test1:[镜像版本号]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>拉取私有镜像</p> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code>docker pull registry.cn-hangzhou.aliyuncs.com/hyj_aliyun/test1:<span class="token punctuation">[</span>镜像版本号<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>将私有镜像库的内容部署到云服务器中</p> <p>安装Docker等操作，详见上一章<code>云服务器使用Docker</code></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">sudo</span> <span class="token function">su</span> - <span class="token comment">#切换为root用户</span>

systemctl status docker <span class="token comment">#通过systemctl命令查看docker是否在运行，看看到返回结果中有没有running，有就是在运行</span>

docker pull <span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span> <span class="token comment">#下载镜像</span>

docker images <span class="token comment"># 查看下载的镜像，查看是否下载成功</span>

docker run -d --name hello-world-container -p <span class="token number">8080</span>:80 <span class="token operator">&lt;</span>镜像名:版本号<span class="token operator">&gt;</span> <span class="token comment">#运行下载的镜像</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>访问</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> &lt;云服务器公网IP&gt;:8080
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022032000354518220.png" alt="image-20220320003545182"></p> <p>注意：如果访问不到，检查下，是否开启防火墙对应端口，是否云服务器安全策略组的入站安全规则是否添加了端口</p></li></ul> <h2 id="dockerfile详解"><a href="#dockerfile详解" class="header-anchor">#</a> Dockerfile详解</h2> <p>Dockerfile文件类似于说明书，定义了构建目标镜像所需的每一个步骤。编写好Dockerfile后，调用构建镜像的命令（docker build）</p> <p>shell</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker build -t 镜像名:版本号
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Docker 引擎会逐一按顺序解析 Dockerfile 中的指令，并根据它们的含义执行对应的操作</p> <h3 id="dockerfile指令"><a href="#dockerfile指令" class="header-anchor">#</a> Dockerfile指令</h3> <ul><li><p><strong>FROM</strong></p> <p><code>Dockerfile</code>的第一个指令一定是 <code>FROM</code> ，该指令指定基础镜像。之后的所有操作都是在该镜像运行的运行的容器中进</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> &lt;image&gt;[:tag] #如果没有指定tag(镜像的版本号) ，默认使用最高版本</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><strong>Label</strong></p> <p>给镜像添加键值对数据</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">LABEL</span> &lt;key1&gt;=&lt;value1&gt;[ &lt;key2&gt;=&lt;value2&gt;[ &lt;key3&gt;=&lt;value3&gt;]]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也可以写多个<code>LABEL</code></p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token comment"># 如果`value`值中包含空格，需要替换为`\空格 `。如果指令没有写完想要换行写，加`\`即可</span>
<span class="token instruction"><span class="token keyword">LABEL</span> multi.label1=<span class="token string">&quot;value1&quot;</span> multi.label2=<span class="token string">&quot;value2-1\ value2-2&quot;</span> other=<span class="token string">&quot;value3&quot;</span></span>
<span class="token instruction"><span class="token keyword">LABEL</span> multi.label1=<span class="token string">&quot;value1&quot;</span> <span class="token operator">\</span>
      multi.label2=<span class="token string">&quot;value2&quot;</span> <span class="token operator">\</span>
      other=<span class="token string">&quot;value3&quot;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>以下命令查看</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker image inspect --format<span class="token operator">=</span><span class="token string">''</span> <span class="token operator">&lt;</span>镜像名/id<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意：父镜像的标签会被继承，但是如果有子镜像有相同的标签，会覆盖父镜像</p></li> <li><p><strong>ENV</strong></p> <p>创建环境变量，后续的Dockerfile指令可以通过$key使用前面设置的环境变量【如果value中需要有空格，需要使用<code>\空格</code>转译】</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>ENV <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span><span class="token operator">=</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token operator">=</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
<span class="token comment">#或者 </span>
ENV <span class="token operator">&lt;</span>key<span class="token operator">&gt;</span><span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>  <span class="token comment">#单个键值对，可省略等于号</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>WORKDIR</strong></p> <p>设置docker容器内部的工作路径（可以理解成，容器内通过cd命令移动到了该路径）。不设置，默认为容器的根目录</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">WORKDIR</span> /app/data #容器内当前路径是/app/data</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以在其中使用ENV定义的变量</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">WORKDIR</span> <span class="token variable">$path</span>/data  #ENV path=/my ，最终就是/my/data</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><strong>COPY与ADD</strong></p> <p>将宿主机的文件复制到容器</p> <p>只有COPY和ADD两个指令的参数路径包含宿主机路径（第一个参数），其他所有指令只能操作容器内部，例如<code>WORKDIR</code>只能设置容器内部的路径，<code>RUN</code>执行shell命令也只是在容器内部执行该命令</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">COPY</span> &lt;src&gt; &lt;dest&gt; #将本地src路径下的文件，复制到容器的dest路径下</span>

<span class="token instruction"><span class="token keyword">ADD</span> &lt;src&gt; &lt;dest&gt; #和COPY功能类似，不过src可以是网络文件下载链接或者是压缩文件，ADD会去下载和解压相应文件，然后放到容器的dest路径下</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意</p> <ul><li><p>第一个参数<code>&lt;src&gt;</code>是：宿主机路径</p> <p><code>&lt;src&gt;</code>必须是相对路径，是相对于<code>Dockerfile</code>文件所在的路径（不是执行<code>docker build</code>的路径），所以<code>.</code>表示宿主机的<code>Dockerfile</code>文件所在的目录</p> <p>指定<code>&lt;src&gt;</code>地址时，如果使用通配符，遵循Go语言的 <a href="https://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener noreferrer">filepath.Match<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 规则</p> <p>如果<code>&lt;src&gt;</code>是目录，则复制目录下的全部内容，但是目录本身没有被复制，只是它里面的内容</p></li> <li><p>第二个参数<code>&lt;dest&gt;</code>是：容器内路径</p> <p>如果使用相对路径，就是以WORKDIR为当前目录（未指定WORKDIR，则默认为容器根目录），所以<code>.</code>代表的是WORKDIR设置的路径。也可以是容器内的绝对路径</p> <p>例如：是相对路径</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>COPY test.txt ./data   <span class="token comment">#将“test.txt”添加到&lt;WORKDIR&gt;/data/下</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>是绝对路径</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>COPY test.txt /app/data/  <span class="token comment">#将“test.txt”复制到容器的/app/data/下</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li><p><strong>RUN</strong></p> <p>在<strong>Docker容器内</strong>执行的命令。注意不是在宿主机执行，常用来在COPY将代码源文件从宿主机复制到Docker容器后，使用RUN安装依赖、编译源码</p> <p>有两种书写形式：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token comment"># shell格式</span>
<span class="token instruction"><span class="token keyword">RUN</span> &lt;命令行命令&gt; </span>

<span class="token comment"># exec 格式（双引号）</span>
<span class="token instruction"><span class="token keyword">RUN</span> [<span class="token string">&quot;可执行文件&quot;</span>, <span class="token string">&quot;参数1&quot;</span>, <span class="token string">&quot;参数2&quot;</span>] </span>

<span class="token comment"># 例如：RUN ./test.php dev offline 等价于 RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注意</strong>：RUN命令可以有多个，但是，指令每执行一次都会在 docker 上新建一层（Layer）。所以过多无意义的层，会造成镜像膨胀过大。例如：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token instruction"><span class="token keyword">RUN</span> install</span>
<span class="token instruction"><span class="token keyword">RUN</span> cd /app</span>
<span class="token instruction"><span class="token keyword">RUN</span> mkdir logs</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上执行会创建 3 层镜像。但是，以 <strong>&amp;&amp;</strong> 符号连接命令，只会创建 1 层镜像，即以下格式：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>注意</strong>：<code>\</code>表示连接下一行的内容，有些时候将多个命令连接起来会是的RUN指令很长，为了有更好的可读性，一般会分为多行，用<code>\</code>分隔表示下一行与本行是同一行</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token instruction"><span class="token keyword">RUN</span> npm install <span class="token operator">\</span>
		&amp;&amp; cd /app <span class="token operator">\</span>
		&amp;&amp; mkdir logs</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p><strong>CMD</strong></p> <p>CMD 指令是容器启动后执行的shell命令，一般用作程序的入口。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖</p> <p>虽然 RUN 指令也可以执行shell命令，但是CMD指令是容器启动后才执行</p> <p>两种格式：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;&lt;可执行文件或命令&gt;&quot;</span>,<span class="token string">&quot;&lt;param1&gt;&quot;</span>,<span class="token string">&quot;&lt;param2&gt;&quot;</span>,...] </span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;&lt;param1&gt;&quot;</span>,<span class="token string">&quot;&lt;param2&gt;&quot;</span>,...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 <code>*.sh</code>文件</p> <p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后⌘ 指令生效。所以如果存在多条指令可以将命令写入shell脚本，使用CMD执行脚本</p> <p>docker run如何覆盖CMD指令?</p> <p>只需要在run命令后，加上其他命令，下面的例子是加了<code>echo 1</code>，这样Dockerfile中指定的CMD就不会执行，而是执行<code>echo 11</code></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run --name 容器名  镜像名:版本 <span class="token builtin class-name">echo</span> <span class="token string">&quot;11&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><strong>ENTRYPOINT</strong></p> <p>ENTRYPOINT 指令是容器启动后执行的shell命令，一般用作程序的入口</p> <p>只有exec格式：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;&lt;executeable&gt;&quot;</span>,<span class="token string">&quot;&lt;param1&gt;&quot;</span>,<span class="token string">&quot;&lt;param2&gt;&quot;</span>,...]</span>

<span class="token comment"># 注意：支持多条命令 ， 例如： 两条命令用 &quot;--&quot; 分割。tini和houndd -conf .</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;tini&quot;</span>,<span class="token string">&quot;--&quot;</span>,<span class="token string">&quot;houndd&quot;</span>,<span class="token string">&quot;-conf&quot;</span>,<span class="token string">&quot;.&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>可以通过<code>docker run</code>追加参数，所以很适合启动时，可以动态传递参数的程序</p> <p>例子：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> centos</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;/bin/echo&quot;</span>,<span class="token string">&quot;this is test entrypoint&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>运行 docker run 时，在docker run最后加参数，会被追加到 ENTRYPOINT 命令后</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run 镜像名:版本号 <span class="token number">123</span> 
<span class="token comment"># 输出 this is test entrypoint 123</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>与CMD结合(当 ENTRYPOINT 与 CMD 同时存在时，CMD 中的内容会作为 ENTRYPOINT 定义命令的参数，最终执行容器启动的只有 ENTRYPOINT 中给出的命令)。也可以参考下面<strong>最佳实践</strong>的例子</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token comment"># dockerfile</span>
<span class="token instruction"><span class="token keyword">FROM</span> centos</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;默认值&quot;</span>]</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;/bin/echo&quot;</span>]</span>

<span class="token comment"># docker run 镜像名:版本号 传入值</span>

<span class="token comment"># 当docker run不传入参数时，默认使用CMD作为参数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>运行 docker run 时，使用了 --entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的命令</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run --entrypoint<span class="token operator">=</span>bin/echo 镜像名:版本号 

<span class="token comment">## 输出 空行</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>最佳实践</strong>：</p> <ul><li>规则一：当 ENTRYPOINT 与 CMD 同时给出时，CMD 中的内容会作为 ENTRYPOINT 定义命令的参数，最终执行容器启动的只有 ENTRYPOINT 中给出的命令</li> <li>规则一：CMD会被覆盖，可以通过覆盖CMD值来实现自定参数</li></ul> <p>示例：</p> <p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> nginx</span>

<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> [<span class="token string">&quot;nginx&quot;</span>, <span class="token string">&quot;-c&quot;</span>] </span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;/etc/nginx/nginx.conf&quot;</span>] # CMD作为默认的参数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>不传参运行，使用CMD作为默认参数</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run  nginx:test

<span class="token comment"># 容器内会默认运行以下命令 ：nginx -c /etc/nginx/nginx.conf</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>传参运行，使用传递的参数（不使用⌘ 作为参数）</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run  nginx:test  /etc/nginx/new.conf

<span class="token comment"># 容器内会默认运行以下命令 ：nginx -c /etc/nginx/new.conf</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>EXPOSE</strong></p> <p>格式</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">EXPOSE</span> &lt;端口1&gt; [&lt;端口2&gt;...]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>EXPOSE 命令只是声明了容器应该打开的端口并没有实际上将它打开，其作用仅仅是可以让运维人员知道应该开启容器的哪些端口</p> <p><code>docker run</code>可覆盖，<code>-p</code>选项才真正的将容器端口和宿主机端口建立映射</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -d --name 容器名 -p 宿主机端口:容器暴露的端口号 <span class="token operator">&lt;</span>镜像名:版本号<span class="token operator">&gt;</span>

<span class="token comment"># `:容器暴露的端口号` 可不写，默认为Dockerfile的EXPOSE字段。写了其他值，容器就会真正开启这个端口</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p><strong>VOLUME</strong></p> <p>格式</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">VOLUME</span> &lt;路径&gt;</span>

<span class="token comment"># 或</span>
<span class="token instruction"><span class="token keyword">VOLUME</span> [<span class="token string">&quot;&lt;路径1&gt;&quot;</span>, <span class="token string">&quot;&lt;路径2&gt;&quot;</span>...]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>docker run</code>可覆盖，将宿主机的目录 /data 映射到容器的 /data2</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run  -v /data:/data2  nginx:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="优化技巧"><a href="#优化技巧" class="header-anchor">#</a> 优化技巧</h3> <h4 id="多阶段构建"><a href="#多阶段构建" class="header-anchor">#</a> 多阶段构建</h4> <p>使⽤多阶段构建，可以在⼀个 Dockerfile 中使⽤多个 FROM 语句。每个 FROM 指令都可以使⽤不同的基础镜像，并表示开始⼀个新的构建阶段。同时可以将⼀个阶段的⽂件复制到另外⼀个阶段，在最终的镜像中保留下需要的内容即可</p> <ul><li><code>FROM xxx AS yyy</code> 指定该阶段的名字为yyy</li> <li><code>--from=yyy</code> 指定引用yyy阶段</li></ul> <p>对阶段构建的用途：</p> <p>例如，Go源代码需要使用Go环境编译，但是编译后的可执行文件是可以直接运行的，不依赖Go环境。</p> <p>如果不使用多阶段构建，只能通过FROM指定一个包含Go环境的镜像，而我们运行可执行文件并不需要该镜像</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> golang <span class="token keyword">As</span> go-builder</span>

<span class="token comment"># 为我们的镜像设置必要的环境变量</span>
<span class="token instruction"><span class="token keyword">ENV</span>  CGO_ENABLED=0 <span class="token operator">\</span>
    GOOS=linux <span class="token operator">\</span>
    GOARCH=amd64</span>

<span class="token comment"># 移动到工作目录：/build</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /build</span>

<span class="token comment"># 将代码复制到容器中</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token comment"># 将我们的代码编译成二进制可执行文件app</span>
<span class="token instruction"><span class="token keyword">RUN</span> go mod tidy &amp;&amp; go build -o app .</span>

<span class="token instruction"><span class="token keyword">FROM</span> alpine</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">go-builder</span></span> /build .</span>
<span class="token comment"># 声明服务端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8888</span>

<span class="token comment"># 启动容器时运行的命令</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;./app&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h4 id="利用缓存"><a href="#利用缓存" class="header-anchor">#</a> 利用缓存</h4> <p>以一个nest服务为例子</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> node:18</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package.json .</span>

<span class="token instruction"><span class="token keyword">COPY</span> *.lock .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm config set registry https://registry.npmmirror.com/</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 3000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [ <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;./dist/main.js&quot;</span> ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>先复制<code>package.json</code>，安装完依赖后再复制其他文件。为什么不直接复制全部文件？如下：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> node:18</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm config set registry https://registry.npmmirror.com/</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 3000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [ <span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;./dist/main.js&quot;</span> ]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>docker 是分层存储的，dockerfile 里的每一行指令是一层，docker引擎会做缓存。每次 docker build 的时候，只会从变化的层开始重新构建，没变的层会直接复用。</p> <p>如果 package.json 没变，那么就不会执行 npm install，直接复用之前的，可以大幅节省安装依赖的时间。如果一开始就把所有文件复制进去，不管 package.json 变没变，只要任何一个文件变了，都会重新 npm install，这样没法充分利用缓存，性能不好</p> <p>与<strong>多阶段构建</strong>结合</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token comment"># 构建阶段</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:18 <span class="token keyword">as</span> build-stage</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">COPY</span> package.json .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install</span>

<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm run build</span>

<span class="token comment"># production stage</span>
<span class="token instruction"><span class="token keyword">FROM</span> node:18 <span class="token keyword">as</span> production-stage</span>

<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">build-stage</span></span> /app/dist /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> <span class="token options"><span class="token property">--from</span><span class="token punctuation">=</span><span class="token string">build-stage</span></span> /app/package.json /app/package.json</span>

<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm install --production # 只安装生产依赖</span>

<span class="token instruction"><span class="token keyword">EXPOSE</span> 3000</span>

<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;/app/main.js&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="忽略文件"><a href="#忽略文件" class="header-anchor">#</a> 忽略文件</h3> <p>build命令用于根据dockerfile指定的任务构建镜像</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker build -t 镜像名:版本号 <span class="token builtin class-name">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中的参数<code>.</code>，是指该命令执行的上下文路径，整个路径下的文件都会被发送给docker引擎用于构建镜像，如果其中有大量无用内容就使得镜像构建的速度很慢</p> <p>实际例子：</p> <p>下面是个前端Node项目的dockerfile（放置在项目根目录下），其中先使用COPY复制整个项目，然后在docker容器内部还会再安装依赖。我们必须在复制时就排除掉node_modules</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> node:16</span>
<span class="token instruction"><span class="token keyword">RUN</span> mkdir /app</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> . /app </span>
<span class="token instruction"><span class="token keyword">RUN</span>  npm install -g cnpm --registry=https://registry.npm.taobao.org&amp;&amp;cnpm install&amp;&amp;cnpm install -g nodemon  #nodemon是用来启动node项目的</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 9091</span>
<span class="token instruction"><span class="token keyword">CMD</span> [<span class="token string">&quot;nodemon&quot;</span>,<span class="token string">&quot;app.js&quot;</span>]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>方案：在项目下新建<code>.dockerignore</code>，写入下面内容就会忽略node_modules目录，COPY指令的执行速度会大大加快</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>node_modules
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="其他技巧"><a href="#其他技巧" class="header-anchor">#</a> 其他技巧</h3> <p>写 Dockerfile 时经常遇到一些运行错误，依赖错误等问题，我们可以运行基础依赖，然后进入容器命令行执行构建步骤。成功后，在做过的步骤写入Dockerfile即可</p> <p>例如：</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code>docker pull node:16
docker run -it -d node:16 bash # 跑起来后进入容器终端配置依赖的软件，然后尝试跑起来自己的软件，最后把所有做过的步骤写入到 Dockerfile 就好了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="docker容器"><a href="#docker容器" class="header-anchor">#</a> Docker容器</h2> <p>容器中运行着指定的镜像，容器之间彼此相互隔离，容器与宿主机也相互隔离</p> <h3 id="容器基础"><a href="#容器基础" class="header-anchor">#</a> 容器基础</h3> <p><strong>创建容器，运行镜像</strong></p> <p>注意：docker run运行的镜如果在本地不存在，则会自动从官方镜像仓库下载</p> <p>docker run作为docker的核心命令涉及到众多的选项，这里仅仅是介绍基础的选项含义，后面的【多容器通信】、【容器挂载目录】还会介绍更多选项</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -d --name 容器名 -p <span class="token number">8080</span>:80 <span class="token operator">&lt;</span>镜像名:版本号<span class="token operator">&gt;</span>

<span class="token comment"># -p 将容器端口映射到本机端口，冒号前是本机端口，冒号后是容器端口</span>
<span class="token comment"># --name 给容器命名，不指定就会随机生成一个名字</span>
<span class="token comment"># -d 在后台运行容器（关闭运行该命令的shell窗口，容器也会继续运行）</span>


<span class="token comment"># --network test 容器使用名为test的网络</span>
<span class="token comment"># --network-alias test 给容器使用的网络设置别名test</span>
<span class="token comment"># -v  volumeName[localAddress]:dockerAddress  这个命令是将本地目录挂载到容器内的目录（bind mount），或者创建名为volumeName的Volume，由容器管理该Volume</span>
<span class="token comment"># --volumes-from dockerName 创建容器时，把名为dockerName的容器的所有Volume挂载到新容器（同一个volume可挂载到多个不同容器）</span>
<span class="token comment"># --rm：容器退出时自动清理容器内部的文件系统。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>查看本地容器列表</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 全部容器</span>
docker <span class="token function">ps</span>

<span class="token comment"># 正在运行状态中的容器</span>
docker <span class="token function">ps</span> -a
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>更改容器状态</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 停止容器</span>
docker stop <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span>
<span class="token comment"># 启动容器</span>
docker start <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span>


<span class="token comment"># 重启容器</span>
docker restart <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span>


<span class="token comment"># 暂停容器</span>
docker pause <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span>
<span class="token comment"># 恢复运行容器</span>
docker unpause <span class="token punctuation">[</span>容器名/容器id<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>容器内部操作</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 登录容器内部</span>
docker <span class="token builtin class-name">exec</span> -it 容器ID或名字 /bin/bash  <span class="token comment"># 第二参数指定使用的shell（bash 、bin/bash、sh 三种shell可选，关键是看容器内安装的系统支持哪个） 登录后，执行echo $SHELL，输出当前shell名</span>


<span class="token builtin class-name">exit</span> <span class="token comment"># 退出容器内shell</span>

docker logs 容器ID/名  <span class="token comment"># 查看容器内终端输出</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>遇到 <code>exec xxx: exec format error</code> ，考虑容器内的镜像是否不支持指定的shell</p> <h3 id="容器网络"><a href="#容器网络" class="header-anchor">#</a> 容器网络</h3> <p>参考：<a href="https://blog.51cto.com/u_16213614/7554657" target="_blank" rel="noopener noreferrer">https://blog.51cto.com/u_16213614/7554657<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="多容器通信"><a href="#多容器通信" class="header-anchor">#</a> 多容器通信</h3> <p>参考：<a href="https://docker.easydoc.net/doc/81170005/cCewZWoN/U7u8rjzF" target="_blank" rel="noopener noreferrer">https://docker.easydoc.net/doc/81170005/cCewZWoN/U7u8rjzF<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>一个项目不是独立运行，可能会依赖多个软件，比如：一个web项目需要mysql数据库、redis等，这就需要多容器之间相互通信</p> <p>容器之间独立，但是每个容器都可以直接访问其他容器的IP。原理如图：</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022092715031420.png" alt="image-20220927150314301"></p> <p>图中的三个容器可以相互ping通是因为有Docker0存在（Docker0相当于一个路由器或者网关），三个容器是以Docker0为中介。每新建一个容器就会出现一个成对存在的网卡，新建容器如果没有指定网络那么默认会在docker0下</p> <blockquote><p>Veth：可以简单理解成虚拟网卡，新容器后其总是成对出现，一端发送数据，另一端就能接收</p></blockquote> <p><strong>link方式</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># nginx容器</span>
docker run -d  -p <span class="token number">80</span>:80 --name my-nginx-1 nginx

<span class="token comment"># alpine容器，通过--link链接前面的nginx容器。--link的参数为 链接的容器：容器别名</span>
docker run -d -it --name my-alpine --link my-nginx-1:other alpine

<span class="token comment"># 登录alpine容器，安装curl工具，使用curl工具访问nginx容器</span>
docker <span class="token builtin class-name">exec</span> -it my-alpine <span class="token function">sh</span> 
apk <span class="token function">add</span> <span class="token function">curl</span>
<span class="token function">curl</span> my-nginx-1 <span class="token comment"># 用别名也是可以的curl other</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>访问到nginx容器</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/2022091813533220.png" alt="image-20220918135331837"></p> <p>link原理：就是在容器的host中为nginx容器的域名指定别名。所以<code>curl 172.17.0.2</code>也是可以访问到nginx容器的</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 在alpine容器中查看hosts文件</span>
<span class="token function">cat</span> /etc/hosts

<span class="token comment">#172.17.0.2	other 58d78fa4462e my-nginx-1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>Docker-compose</strong></p> <p>如果很多容器之间需要进行通讯，使用link的方式会很繁琐。可以使用Docker-compose</p> <p>详细内容参见下一章【Docker-Compose】</p> <p><strong>创建网络</strong></p> <p>每个容器之间相互独立，但是往往一个项目不是独立运行，可能会依赖多个软件，比如：一个web项目需要mysql数据库、redis等，这就需要多容器之间相互通信。创建docker网络，将两个容器运行在同一个网络中(不指定网络，就默认在Docker0下)</p> <p>docker容器网络文档： <a href="https://docs.docker.com/engine/reference/commandline/network/" target="_blank" rel="noopener noreferrer">docker network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p>创建网络</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker network create test-net <span class="token comment"># 创建名为test-net的网络</span>
docker network list <span class="token comment"># 查询网络列表 ，确定是否成功创建test-net网路</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>运行redis容器，接入网<code>test-net</code>，并给网络起别名<code>redis</code></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -d --name redis -p <span class="token number">6379</span>:6379 --network test-net --network-alias redisnet redis:latest
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>运行另一个容器，使用<code>--network-net</code>指令，接入同一个网络，如果想要访问redis，redis地址 <code>redisnet:6379</code></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -d --name xxx --network test-net  xxx:xxx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h3 id="容器挂载目录"><a href="#容器挂载目录" class="header-anchor">#</a> 容器挂载目录</h3> <p><strong>现存问题</strong> ：</p> <ul><li>使用 Docker 运行后，我们改了项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很是麻烦。</li> <li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul> <p><strong>解决方法</strong>：</p> <p><a href="https://docs.docker.com/storage/" target="_blank" rel="noopener noreferrer">文档：docker 存储<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p><code>bind mount</code>：将项目的实际目录挂载到容器中，当项目代码发生变动，容器内的项目也会发生同样变动。适合于本地开发项目，代码更改后，容器内也会跟随变动</p></li> <li><p><code>volume</code>（官方推荐）：容器在宿主文件系统中创建一块区域，将数据写入该区域，并由容器管理该区域数据。删除容器，数据不会丢失，且数据可挂载到多个容器中。适合于第三方成熟镜像，安装到容器中，容器自行管理数据</p></li> <li><p><code>tmpfs mount</code>：将数据存储在内存中</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013117440247320.png" alt="image-20220131174402473"></p></li></ul> <p><strong>bind mount</strong></p> <p>使用选项<code>-v localAddress:/app</code>第一个参数是项目本地根目录，第二个参数是容器根目录<code>/app</code></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 项目目录下</span>
docker run -p <span class="token number">8080</span>:8080 --name test-hello -d  -v localAddress:/app test:v1 <span class="token comment"># localAddress替换为项目本地根目录</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>volume</strong></p> <p>使用选项<code>-v volumeName:/app</code>第一个参数是volume名字，第二个参数是容器根目录<code>/app</code></p> <p><strong>注意</strong></p> <p><code>bind mount</code> 和<code>Volume</code>的选项都是-v，但是第一个参数不同</p> <p><strong>查看bind mount和volume</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013117574017320.png" alt="image-20220131175740173"></p> <p>Mounts左侧是容器内路径，右侧是该容器内路径对应的本地路径（两种方式挂载目录都是在这里查看）</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022013117584230920.png" alt="image-20220131175842309"></p> <h2 id="docker-compose"><a href="#docker-compose" class="header-anchor">#</a> Docker-Compose</h2> <p>一个项目可能会依赖更多的软件，例如：一个后端服务项目，其依赖mysql、redis等容器</p> <p>如果一一去配置多个容器会比较复杂，所以，我们可以使用Docker-Compose一次性把一个项目的多个依赖软件配置好</p> <p>Docker-Compose<a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener noreferrer">中文文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="安装"><a href="#安装" class="header-anchor">#</a> 安装</h3> <ul><li><p>桌面版Docker，自带Docker-Compose</p></li> <li><p>服务端版，需要手动安装<a href="https://docs.docker.com/compose/install/#install-compose-on-linux-systems" target="_blank" rel="noopener noreferrer">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>输入<code>docker compose</code>，出现以下提示，证明安装成功</p> <p><img src="https://hedaodao-1256075778.cos.ap-beijing.myqcloud.com/Docker/image-20220201115026305%20.png" alt="image-20220201115026305"></p></li></ul> <h3 id="配置文件"><a href="#配置文件" class="header-anchor">#</a> 配置文件</h3> <p>Docker-Compose读取配置文件<code>docker-compose.yml</code>或<code>docker-compose.yaml</code>，来组织起多个容器。</p> <p><a href="https://www.runoob.com/docker/docker-compose.html" target="_blank" rel="noopener noreferrer">Docker-Compose指令<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>项目根目录下新建<code>docker-compose.yml</code>文件，这里对部分指令含义进行介绍</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token comment"># 一、docker-compose版本号</span>
<span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.7&quot;</span>

<span class="token comment"># 二、服务配置(每个服务都是一个容器)</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
	<span class="token comment">#第一个服务</span>
  <span class="token key atrule">myapp</span><span class="token punctuation">:</span> <span class="token comment"># 服务名</span>
  	<span class="token key atrule">container_name</span><span class="token punctuation">:</span> app<span class="token punctuation">-</span>server <span class="token comment">#容器名</span>
  	<span class="token key atrule">restart</span><span class="token punctuation">:</span> always <span class="token comment">#always：服务挂了自动重启；unless-stopped：服务挂了不重启</span>
  	<span class="token key atrule">networks</span><span class="token punctuation">:</span>  <span class="token comment">#指定网络，这里两个服务指定的网络一样，表示在一个网络下</span>
  		<span class="token punctuation">-</span> postnet
    <span class="token key atrule">build</span><span class="token punctuation">:</span> . <span class="token comment"># build指定Dockerfil文件所在的目录，`.`代表Dockerfile文件在当前目录</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span> myredis <span class="token comment"># 依赖，用来指定顺序，本服务依赖于myredis启动，myredis启动后myapp才启动（这里注意有一个大坑，myredi服务启动后，myapp就启动了，这时候redis可能还未就绪）</span>
    <span class="token comment"># 依赖可以指定多个，用数组形式</span>
    <span class="token comment"># -myredis1</span>
    <span class="token comment"># - myredi2</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>   <span class="token comment"># 指定映射端口</span>
      <span class="token punctuation">-</span> 80<span class="token punctuation">:</span><span class="token number">8080</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 挂载数据卷，将容器内./data挂载到宿主机/app目录下</span>
      <span class="token punctuation">-</span> ./data<span class="token punctuation">:</span>/app
    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 容器内的环境变量</span>
      <span class="token punctuation">-</span> TZ=Asia/Shanghai
      
  <span class="token comment">#地第二个服务    </span>
  <span class="token key atrule">myredis</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>latest <span class="token comment">#image字段指镜像，这里没有使用dockerfile</span>
    <span class="token key atrule">networks</span><span class="token punctuation">:</span> 
  		<span class="token punctuation">-</span> postnet
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> redis<span class="token punctuation">:</span>/data
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> TZ=Asia/Shanghai

<span class="token comment"># 三、其他配置、网络、全局规则</span>
<span class="token key atrule">volumes</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p><strong>注意</strong>：容器默认时间不是北京时间，增加 TZ=Asia/Shanghai 可以改为北京时间</p> <p><strong>Docker-compose相关命令</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># 项目根目录下</span>
docker-compose up -d <span class="token comment"># 执行docker-compose配置，-d是后台运行的含义</span>

docker-compose <span class="token function">ps</span> <span class="token comment"># 查看运行状态</span>

docker-compose stop <span class="token comment"># 停止运行</span>

docker-compose restart <span class="token comment"># 重启     </span>
docker-compose restart service-name <span class="token comment"># 重启单个服务</span>

docker-compose <span class="token builtin class-name">exec</span> service-name <span class="token function">sh</span> <span class="token comment"># 进入容器指定服务的命令行</span>
docker-compose logs <span class="token punctuation">[</span>service-name<span class="token punctuation">]</span> <span class="token comment"># 查看容器运行log</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="备份和迁移数据"><a href="#备份和迁移数据" class="header-anchor">#</a> 备份和迁移数据</h2> <p><strong>区分目录挂载的方式</strong></p> <ul><li>如果使用<code>bind mount</code>直接把宿主机的目录挂进去容器，那迁移数据很方便，直接复制目录就好了</li> <li>如果使用<code>volume</code>方式挂载的，由于数据是由容器创建和管理的，需要用特殊的方式把数据弄出来。</li></ul> <p><strong>备份和导入 Volume 的流程</strong></p> <p>备份：</p> <ul><li><p>运行一个 ubuntu 的容器，挂载需要备份的 volume 到ubuntu容器，并且挂载宿主机目录到容器里的备份目录。</p></li> <li><p>运行 tar 命令把容器中的/data/下的数据压缩为一个文件，压缩后的文件放在备份目录下</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020211293434120.png" alt="image-20220202112934341"></p></li></ul> <p>导入：</p> <ul><li>运行 ubuntu 容器，挂载目标容器的 volume，并且挂载宿主机备份文件所在目录到ubuntu容器里</li> <li>运行 tar 命令解压备份文件到volume所在的文件夹</li></ul> <p><strong>以mongodb为例</strong></p> <p>备份：</p> <ul><li><p>运行mongodb容器，将容器的/data目录，存储到名为 mongo-data 的Volume中</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -p <span class="token number">27018</span>:27017 --name mongo -v mongo-data:/data -d mongo:4.4
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>本地没有mongo这个镜像，会从远程镜像仓库下载</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020120215866320.png" alt="image-20220201202158663"></p> <p>然后，运行到容器</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020120230975920.png" alt="image-20220201202309759"></p> <p>同时能看到名为 mongo-data 的Volume</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020120190851820.png" alt="image-20220201201908518"></p> <p>这里可以看到mongo的volume数据都是放在容器的/data/目录下</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020211371009620.png" alt="image-20220202113710096"></p></li> <li><p>使用以下命令</p> <p>shell</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run --rm --volumes-from mongo -v /Users/yc/Desktop/backup:/backup ubuntu <span class="token function">tar</span> cvf /backup/backup.tar /data/
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><p><code>--volumes-from mongo</code>将mongo的所有Volume挂载到ubuntu容器，mongo中Volume数据在容器的/data/下，挂载到ubuntu下也是在/data/下</p></li> <li><p><code>-v /Users/yc/Desktop/backup:/backup</code> 使用bind mount，将本地目录<code>/Users/yc/Desktop/backup</code>挂载到ubuntu容器内的<code>/backup</code>目录</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020211163569720.png" alt="image-20220202111635697"></p></li> <li><p><code>tar cvf /backup/backup.tar /data/</code> 压缩/data/，将压缩包命名为backup.tar放在/backup/backup.tar下。这里可以看出来，在压缩命令中使用的容器内地址</p></li> <li><p><code>--rm</code>ubuntu容器运行完，直接删除容器</p></li></ul></li> <li><p>mongo的Volume备份到了宿主机的<code>/Users/yc/Desktop/backup</code>目录下，可以看到多了一个<code>backup.tar</code>文件</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-2022020210493962920.png" alt="image-20220202104939629"></p></li></ul> <p>迁移</p> <ul><li><p>删除之前的mongo容器，新建一个新的mongo容器。这个容器没数据</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -p <span class="token number">27018</span>:27017 --name mongo -v mongo-data:/data -d mongo:4.4
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>新mongo容器的Volume挂载到ubuntu容器中，然后解压文件把数据放进Volume中，运行完毕后，删除ubuntu容器</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run --rm --volumes-from mongo -v d:/backup:/backup ubuntu <span class="token function">bash</span> -c <span class="token string">&quot;cd /data/ &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>注意</strong>：strip 1 表示解压时去掉前面1层目录，因为压缩时包含了绝对路径</p></li></ul> <h2 id="自动化流程"><a href="#自动化流程" class="header-anchor">#</a> 自动化流程</h2> <p>一般部署项目的流程：</p> <p><strong>本地开发代码</strong> —&gt; <strong>编译代码</strong> ——&gt; <strong>打包成镜像</strong> ——&gt;<strong>上传私有镜像仓库</strong> ——&gt; <strong>在服务器上拉取镜像</strong> ——&gt; <strong>运行镜像</strong></p> <p>为了提高效率，实际上这套流程还可以继续精简，以我所在的公司为例：</p> <p><strong>本地开发代码</strong> —&gt; <strong>push到公司内部的git仓库</strong> ——&gt; <strong>在公司自研的部署平台上选择对应仓库和分支</strong> ——&gt;<strong>自动打包git仓库中的对应代码，上传私有镜像仓库，在服务器上拉取镜像，运行镜像</strong></p> <h2 id="常用命令"><a href="#常用命令" class="header-anchor">#</a> 常用命令</h2> <p><strong>构建镜像(images)</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker build -t 镜像名:版本号  -f Dockerfile的路径 发送给Docker引擎的目录

<span class="token comment"># -t指定构建镜像的名字和版本号</span>
<span class="token comment"># 如果执行该命令的目录，就是Dockerfile所在的目录，路径一般写`.`，代表当前路径，即把当前路径发送给Docker引擎</span>
<span class="token comment"># -f Dockerfile的路径。项目中为了区分生产测试环境的Dockerfile,一般会命名为Dockerfile.prod、Dockerfile.dev等，这时候就需要使用-f指定路径</span>

docker build  -t 镜像名:版本号  -f ./Dockerfile.prod Dockerfile的路径
<span class="token comment"># -f 有时候项目下的构建镜像的文件可能不叫dockerfile，可以用-f指定构建文件所在的位置</span>
<span class="token comment"># 一般的命名风格 Dockerfile.qa 、 Dockerfile.dev</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>创建容器，运行指定镜像</strong></p> <p>如果本地没有该镜像，会自动从远程仓库下载镜像，然后运行到容器</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker run -d --name 容器名 -p <span class="token number">8080</span>:80 <span class="token operator">&lt;</span>镜像名:版本号<span class="token operator">&gt;</span>

<span class="token comment"># -p 将容器端口映射到本机端口，冒号前是本机端口，冒号后是容器端口</span>
<span class="token comment"># --name 给容器命名，不指定就会随机生成一个名字</span>
<span class="token comment"># -d 在后台运行容器（关闭运行该命令的shell窗口，容器也会继续运行</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>volume相关</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker volume <span class="token function">ls</span> <span class="token comment"># 查看volume列表</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>网络相关</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker network <span class="token function">ls</span> <span class="token comment"># 查看网络列表</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>docker命令大全</strong></p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/dockerimg20.jpeg" alt="dockerimg"></p> <p><code>docker info</code> 查询docker的信息，Registry字段为docker的镜像源</p> <h2 id="常用的基础镜像"><a href="#常用的基础镜像" class="header-anchor">#</a> 常用的基础镜像</h2> <h3 id="alpine"><a href="#alpine" class="header-anchor">#</a> Alpine</h3> <p>精简版的Linux系统</p> <p>特点：</p> <ul><li><p>使用APK包管理工具</p> <p>APK下载软件有时候会很慢，可以在dockerfile中指定国内的站点</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#更新Alpine的软件源为国内（清华大学）的站点，因为从默认官源拉取实在太慢了。。。</span>
RUN <span class="token builtin class-name">echo</span> <span class="token string">&quot;https://mirror.tuna.tsinghua.edu.cn/alpine/v3.4/main/&quot;</span> <span class="token operator">&gt;</span> /etc/apk/repositories
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>只支持bin/sh</p> <p>如果需要支持bash，可以在dockerfile中使用AKP下载</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">RUN</span> apk add bash</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>轻量级，下图是各个Linxu镜像的大小</p> <p><img src="https://cdn.jsdelivr.net/gh/zyzylifi/blog-picture/images/image-20220517115557559.png" alt="image-20220517115557559"></p></li></ul> <p>目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境</p> <h3 id="node镜像"><a href="#node镜像" class="header-anchor">#</a> Node镜像</h3> <p>安装了node环境的Linux系统，但是不同镜像基于的系统不同</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>node:&lt;version&gt;

基于Debian,官方默认镜像。当你不确定你需要什么的时候选择这个就对了。这个被设计成可以丢弃的镜像，也就是可以用作构建源码使用（分阶段构建），体积挺大。


node:&lt;version&gt;-slim
基于Debian， 删除了很多默认公共的软件包，只有node运行的最小环境。除非你有空间限制，否则推荐使用默认镜像。

node:&lt;version&gt;-alpine
基于alpine, 比Debian小的多。如果想要最小的镜像，可以选择这个做为base。需要注意的是，alpine使用musl代替glibc。一些c环境的软件可能不兼容。但大部分没问题。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>例子</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> node:16</span>

<span class="token comment"># 修改时区</span>
<span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">&quot;${TZ}&quot;</span> &gt; /etc/timezone <span class="token operator">\</span>
    &amp;&amp; ln -sf /usr/share/zoneinfo/<span class="token variable">${TZ}</span> /etc/localtime <span class="token operator">\</span>
    &amp;&amp; apt update <span class="token operator">\</span>
    &amp;&amp; apt install -y tzdata <span class="token operator">\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>


<span class="token instruction"><span class="token keyword">RUN</span> mkdir app</span>
<span class="token instruction"><span class="token keyword">WORKDIR</span> /app</span>
<span class="token instruction"><span class="token keyword">COPY</span> . .</span>

<span class="token instruction"><span class="token keyword">RUN</span> npm config set registry https://registry.npm.taobao.org &amp;&amp; npm install</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="踩坑第一弹"><a href="#踩坑第一弹" class="header-anchor">#</a> 踩坑第一弹</h2> <p>Dockerfile中我们常用的基础镜像，一般就是alpine，这是一个精简版的Linux系统</p> <p>Dockerfile的第一句拉取基础镜像，一般都是一个Linux系统，比如</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> golang:1.17.1-alpine  #包含golang环境的Linux</span>
<span class="token instruction"><span class="token keyword">FROM</span> nginx:1.17.1-alpine   #包含nginx的Linux</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后，我们在这个系统的基础上进行一些添加操作</p> <p>我在实践中踩的第一个大坑就在这里，公司的部署系统远程连接Docker容器（就是使用docker exec）默认使用的是bash，但是由于alpine不支持bash，只支持bin/sh所以导致一直无法连接。</p> <p>解决方法有两个，其核心就是在镜像中添加bash：</p> <ul><li><p>构建自己的基础镜像，这个基础镜像中就添加好bash</p> <p>这个就用到【常用命令】里补充的commit命令了</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>docker pull <span class="token function">bash</span> <span class="token comment">#下载bash镜像，这里面有一个</span>

docker images <span class="token comment"># 查看所有镜像，判断是否下载好了bash</span>

docker run -itd <span class="token function">bash</span>

docker <span class="token function">ps</span> -a <span class="token comment">#找到运行起来bash镜像的容器的ID</span>
 
docker <span class="token builtin class-name">exec</span> -it 容器ID  <span class="token function">bash</span>  <span class="token comment">#通过ID进入bash交互模式</span>

apk <span class="token function">add</span> xxx <span class="token comment">#安装xxx软件</span>


docker commit 容器ID 镜像名:版本号 <span class="token comment">#把容器打包成镜像，指定镜像名和版本号</span>

docker images <span class="token comment">#就能找到刚刚打包的镜像了</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>上传镜像到镜像仓库，参考【发布到私有镜像】章节</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>给镜像打tag

push到仓库
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在dockerfile使用我们打包的基础镜像</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> 仓库地址/命名空间/镜像名:版本号</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>在需要部署的项目根文件夹下的Dockerfile中下载bash，然后使用<code>docker build</code>基于Dockerfile文件构建镜像。我这里以一个alpine为基础镜像</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token instruction"><span class="token keyword">FROM</span> golang:1.17.1-alpine  #包含golang环境的Linux</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk add --no-cache --upgrade bash #安装一个bash</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul> <p>还有一点要特别注意：</p> <p>我们这里是安装bash，两种方案速度相差不到，如果是安装一个特别大的软件，还是建议使用第一种方法，因为第二种方法就是容器自动去网络上下载，这样比较慢，而第一种方法，是把软件已经添加到镜像里了，我们可以把这个镜像上传到公司的镜像仓库，当dockerfile执行<code>FROM</code>时，直接在内网拉取这个镜像，这样速度就比较快了</p> <h2 id="踩坑第二弹-容器时间"><a href="#踩坑第二弹-容器时间" class="header-anchor">#</a> 踩坑第二弹: 容器时间</h2> <p>容器默认时间不是北京时间</p> <p>本地开发使用的北京时间（东八区时间），但是容器内使用的是UTC时间。导致容器的设置的定时任务无法按时执行</p> <p>定时任务使用的是<code>node-schedule</code>这个库</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">const</span> schedule <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;node-schedule&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
schedule<span class="token punctuation">.</span><span class="token function">scheduleJob</span><span class="token punctuation">(</span><span class="token string">'0 0 8 * * *'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;北京时间8点执行&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我希望定时脚本能在北京时间8点执行，但是实际上会在北京时间16点执行。</p> <p>因为node-schedule设置的时间，是按照当前时区设置的，而容器内是UTC时间</p> <p><strong>解决方案</strong>：</p> <p>登录容器内部系统，输入<code>apt</code>、<code>apk</code>，能正常输出相关命令，就能判断系统使用了哪个包管理器</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>docker exec -it 容器id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>dockerfile增加</p> <div class="language-dockerfile line-numbers-mode"><pre class="language-dockerfile"><code><span class="token comment">#环境变量先设置</span>
<span class="token instruction"><span class="token keyword">ENV</span> TZ=Asia/Shanghai</span>

<span class="token comment">#使用apk的用下面的（基于Alpine镜像的都自带apk)</span>
<span class="token instruction"><span class="token keyword">RUN</span> apk update <span class="token operator">\</span>
    &amp;&amp; apk add tzdata <span class="token operator">\</span>
    &amp;&amp; echo <span class="token string">&quot;${TZ}&quot;</span> &gt; /etc/timezone <span class="token operator">\</span>
    &amp;&amp; ln -sf /usr/share/zoneinfo/<span class="token variable">${TZ}</span> /etc/localtime <span class="token operator">\</span>
    &amp;&amp; rm /var/cache/apk/*</span>

<span class="token comment">#使用apt的用下面的</span>
<span class="token instruction"><span class="token keyword">RUN</span> echo <span class="token string">&quot;${TZ}&quot;</span> &gt; /etc/timezone <span class="token operator">\</span>
    &amp;&amp; ln -sf /usr/share/zoneinfo/<span class="token variable">${TZ}</span> /etc/localtime <span class="token operator">\</span>
    &amp;&amp; apt update <span class="token operator">\</span>
    &amp;&amp; apt install -y tzdata <span class="token operator">\</span>
    &amp;&amp; rm -rf /var/lib/apt/lists/*</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>参考：<a href="https://juejin.cn/post/7082670118257295391" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7082670118257295391<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:75px;bottom:0px;width:135px;height:300px;z-index:99999;opacity:1;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div><div class="reco-bgm-panel" data-v-39f9e6e0><audio id="bgm" src="https://aeiherumuh10.gitee.io/blog-picture/bgm/晴天-周杰伦.mp3" data-v-39f9e6e0></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><img src="https://aeiherumuh10.gitee.io/blog-picture/bgm/JayChou.jpg" data-v-39f9e6e0></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><div class="reco-bgm-cover" style="background-image:url(https://aeiherumuh10.gitee.io/blog-picture/bgm/JayChou.jpg);" data-v-39f9e6e0><div class="mini-operation" style="display:none;" data-v-39f9e6e0><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-39f9e6e0></i></div> <div class="falut-message" style="display:none;" data-v-39f9e6e0>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><div class="info-box" data-v-39f9e6e0><i class="reco-bgm reco-bgm-music music" data-v-39f9e6e0></i>晴天</div> <div class="info-box" data-v-39f9e6e0><i class="reco-bgm reco-bgm-artist" data-v-39f9e6e0></i>周杰伦</div> <div class="reco-bgm-progress" data-v-39f9e6e0><div class="progress-bar" data-v-39f9e6e0><div class="bar" data-v-39f9e6e0></div></div></div> <div class="reco-bgm-operation" data-v-39f9e6e0><i class="reco-bgm reco-bgm-last last" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-play play" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-next next" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-39f9e6e0></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-39f9e6e0></i> <div class="volume-bar" data-v-39f9e6e0><div class="bar" data-v-39f9e6e0></div></div></div></div> <div class="reco-bgm-left-box" data-v-39f9e6e0 data-v-41bcba48 data-v-39f9e6e0><i class="reco-bgm reco-bgm-left" data-v-39f9e6e0></i></div></div></div></div></div>
    <script src="/zeno-blog/assets/js/app.9211a5da.js" defer></script><script src="/zeno-blog/assets/js/3.3b039ebf.js" defer></script><script src="/zeno-blog/assets/js/1.8ae41a42.js" defer></script><script src="/zeno-blog/assets/js/28.903942bf.js" defer></script><script src="/zeno-blog/assets/js/9.54de9460.js" defer></script>
  </body>
</html>
